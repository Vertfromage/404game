<!-- Resources used -->
<!-- https://gist.github.com/xem/a7ff7215375520d89b73beeabd7b16bd -->
<!-- https://www.emanueleferonato.com/2014/01/17/creation-of-an-html5-tile-based-platform-game-with-no-engines-behind-pure-code/ -->

<body style=margin:0>
    <canvas id=a>
        <script>
            // initialize 2D canvas (c)
            // initialize game state (s)
            // initialize keys states (u,r,d,l for directions, k for all the keyboard)
            c = a.getContext`2d`, k = [u = r = d = l = s = 0]

            // (initialize your global variables here)
            c.width = document.documentElement.clientWidth;
            c.height = document.documentElement.clientHeight;

            // update u,l,d,r globals when an arrow key/wasd/zqsd is pressed or released
            // update k[keyCode] if any other key is pressed/released
            onkeydown = onkeyup = e => k[e.which] = self['lld*rlurdu'[e.which % 32 % 17]] = e.type[5]

            function makeRect(x, y, width, height, speed, color) {
                if (!color) color = '#000000';
                return {
                    x: x,
                    y: y,
                    w: width,
                    h: height,
                    s: speed,
                    c: color,
                    draw: function () {
                        c.fillStyle = this.c;
                        c.fillRect(this.x, this.y, this.w, this.h);
                    }
                };
            }

            var count = 0;
            var pSpeed = 4;
            var pLength = 0.05 * c.width;
            var p = makeRect(0, 0, pLength, pLength, pSpeed, '#FFA62F');
            var toX;
            var toY;

            var levelCols = 32;// level width, in tiles
            var levelRows = 16;// level height, in tiles
            var playerCol = 10; // player starting column
            var playerRow = 5; // player starting row

            var level = [      // the 32x16 level - 1=wall, 0=empty space
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];
            // Note: If tight on space we could flip spots in the level to make different layouts. 
            // use a [[i,j]] array for any changes and loop in reusable function.

            // start game loop (60fps)
            // the canvas is cleared and adjusted to fullscreen at each frame
            // draw each screen in the switch's cases
            // in each screen, you can make key presses update the game state
            // ex: "press enter to open the menu" => `if(k[13])s=1;`
            setInterval(e => {
                a.width = innerWidth, a.height = innerHeight;
                switch (s) {
                    case 0: title();
                        break;
                    case 1: street(); if (k[13]) {
                        p.y = playerRow * c.w / 16;				// converting Y player position from tiles to pixels
                        p.x = playerCol *= c.w / 16;
                        s = 2;
                    }
                        break;
                    case 2: inside();
                        break;
                    case 3: // ex: draw game over screen
                        break;
                }
            }, 16)

            // handle click/touch events
            // globals x and y contain the pointer's coordinates
            // in each screen, you can make a click update the game state
            // ex: "game over if we click on the bottom half of the screen" => `if(y>h/2)s=3;`
            onclick = e => {
                x = e.pageX; y = e.pageY;
                switch (s) {
                    case 0: if (y > c.h / 2) s = 1;
                        break;
                    case 1: toX = x; toY = y;
                        break;
                    case 2: toX = x; toY = y; count=12;
                        break;
                    case 3: // react to clicks on screen 3
                        break;
                }
            }
            //scenes
            // Title
            function title() {
                c.w = document.documentElement.clientWidth;
                c.h = document.documentElement.clientHeight;
                c.font = '60px Arial';
                c.textAlign = 'center';
                c.fillStyle = '#FFA62F';
                c.fillText('Robot Mission 404', c.w / 2, c.h / 4);
                c.font = '30px Arial';
                c.fillText('Click to go to street', c.w / 2, c.h / 2);
            }

            function street() {
                c.w = document.documentElement.clientWidth;
                c.h = document.documentElement.clientHeight;
                c.font = '60px Arial';
                c.textAlign = 'center';
                c.fillStyle = '#FFA62F';
                c.fillText('Robot Mission 404', c.w / 2, c.h / 6);
                c.font = '30px Arial';
                c.fillText('Press enter to go inside', c.w / 2, c.h / 2);
                touchMove(toX, toY);
                //keyMove();
                p.draw();
            }

            function inside() {
                c.w = document.documentElement.clientWidth;
                c.h = document.documentElement.clientHeight;

                c.font = '60px Arial';
                c.textAlign = 'center';
                c.fillStyle = '#FFA62F';
                c.fillText('Inside', c.w / 2, c.h / 2);
                //ToDo
                inR();
                //player
                p.h = p.w = c.w / levelCols;
                keyMove();
                if(count>0){
                    touchMove(toX,toY);
                    count--;
                }
                bump();
                p.y += p.s;
                p.draw();
            }
            function inR() {
                var tileSize = c.w / levelCols;
                // converting X player position from tiles to pixels

                c.width = tileSize * levelCols;   // canvas width. Won't work without it even if you style it from CSS
                c.height = tileSize * levelRows; // canvas height. Same as before

                c.fillStyle = "#ff0000";
                for (i = 0; i < levelRows; i++) {
                    for (j = 0; j < levelCols; j++) {
                        if (level[i][j] == 1) {
                            c.fillRect(j * tileSize, i * tileSize, tileSize, tileSize);
                        }
                    }
                }

            }
            function bump() {
                // check for horizontal collisions
                var tileSize = c.w / levelCols;
                var baseCol = Math.floor(p.x / tileSize);
                var baseRow = Math.floor(p.y / tileSize);
                var colOverlap = p.x % tileSize;
                var rowOverlap = p.y % tileSize;

                if ((level[baseRow][baseCol + 1] && !level[baseRow][baseCol]) || (level[baseRow + 1][baseCol + 1] && !level[baseRow + 1][baseCol] && rowOverlap)) {
                    p.x = (baseCol * tileSize);
                }
                if ((!level[baseRow][baseCol + 1] && level[baseRow][baseCol]) || (!level[baseRow + 1][baseCol + 1] && level[baseRow + 1][baseCol] && rowOverlap)) {
                    p.x = ((baseCol + 1) * tileSize);
                }
                // check for vertical collisions
                if ((level[baseRow + 1][baseCol] && !level[baseRow][baseCol]) || (level[baseRow + 1][baseCol + 1] && !level[baseRow][baseCol + 1] && colOverlap)) {
                    p.y = (baseRow * tileSize);
                }
                if ((!level[baseRow + 1][baseCol] && level[baseRow][baseCol]) || (!level[baseRow + 1][baseCol + 1] && level[baseRow][baseCol + 1] && colOverlap)) {
                    p.y = ((baseRow + 1) * tileSize);
                }
            }

            function keyMove() {
                if (u) { p.y -= p.s * 5;};
                if (d) { p.y += p.s; };
                if (r) { p.x += p.s; };
                if (l) { p.x -= p.s; };
            }

            function touchMove(x, y) {
                if ((p.x > x + p.s || p.x < x - p.s)
                    || (p.y > y + p.s || p.y < y - p.s)) {
                    if (p.x != x) {
                        if (x > p.x) {
                            p.x += p.s;
                        } else {
                            p.x -= p.s;
                        }
                    } if (p.y != y) {
                        if (y > p.y) {
                            p.y += p.s;
                        } else {
                            p.y -= p.s*5;
                        }
                    }
                }
            }


        </script>